.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Math::Polygon::Clip 3"
.TH Math::Polygon::Clip 3 "2018-01-03" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::Polygon::Clip \- frame a polygon in a square
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 2
\& Math::Polygon::Clip
\&   is a Exporter
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& my @poly  = ( [1,2], [2,4], [5,7], [1, 2] );
\& my @box   = ( $xmin, $ymin, $xmax, $ymax );
\&
\& my $boxed = polygon_clip \e@box, @poly;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Cut-off all parts of the polygon which are outside the box
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.ie n .IP "\fBpolygon_fill_clip1\fR(\e@box, @points)" 4
.el .IP "\fBpolygon_fill_clip1\fR(\e@box, \f(CW@points\fR)" 4
.IX Item "polygon_fill_clip1(@box, @points)"
Clipping a polygon into rectangles can be done in various ways.
With this algorithm (which I designed myself, but may not be new), the
parts of the polygon which are outside the \f(CW@box\fR are mapped on the borders.
The polygon stays in one piece.
.Sp
Returned is one list of points, which is cleaned from double points,
spikes and superfluous intermediate points.
.ie n .IP "\fBpolygon_fill_clip2\fR(\e@box, @points)" 4
.el .IP "\fBpolygon_fill_clip2\fR(\e@box, \f(CW@points\fR)" 4
.IX Item "polygon_fill_clip2(@box, @points)"
\&\fBTo be implemented\fR.  The polygon falls apart in fragments, which are not
connected: paths which are followed in two directions are removed.
This is required by some applications, like polygons used in geographical
context (country contours and such).
.ie n .IP "\fBpolygon_fill_clip3\fR( \e@box, $out\-$poly, [$in\-$polys] )" 4
.el .IP "\fBpolygon_fill_clip3\fR( \e@box, \f(CW$out\fR\-$poly, [$in\-$polys] )" 4
.IX Item "polygon_fill_clip3( @box, $out-$poly, [$in-$polys] )"
\&\fBTo be implemented\fR.  A surrounding polygon, with possible
inclussions.
.ie n .IP "\fBpolygon_line_clip\fR(\e@box, @points)" 4
.el .IP "\fBpolygon_line_clip\fR(\e@box, \f(CW@points\fR)" 4
.IX Item "polygon_line_clip(@box, @points)"
Returned is a list of \s-1ARRAYS \s0(possibly 0 long) containing line pieces
from the input polygon (or line).
.Sp
example:
.Sp
.Vb 5
\& my @points = ( [1,2], [2,3], [2,0], [1,\-1], [1,2] );
\& my @bbox   = ( 0, \-2, 2, 2 );
\& my @l      = polygon_line_clip \e@bbox, @points;
\& print scalar @l;      # 1, only one piece found
\& my @first = @{$l[0]}; # first is [2,0], [1,\-1], [1,2]
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of Math-Polygon distribution version 1.10,
built on January 03, 2018. Website: \fIhttp://perl.overmeer.net/CPAN/\fR
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 2004\-2018 by [Mark Overmeer]. For other contributors see ChangeLog.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://dev.perl.org/licenses/\fR
