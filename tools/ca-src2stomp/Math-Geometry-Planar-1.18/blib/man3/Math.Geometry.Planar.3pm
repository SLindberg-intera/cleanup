.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Planar 3"
.TH Planar 3 "2011-03-10" "perl v5.22.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::Geometry::Planar \- A collection of planar geometry functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\& use Math::Geometry::Planar;
\& $polygon = Math::Geometry::Planar\->new; creates a new polygon object;
\& $contour = Math::Geometry::Planar\->new; creates a new contour object;
.Ve
.PP
Formats
.IX Subsection "Formats"
.PP
A point is a reference to an array holding the x and y coordinates of the point.
.PP
.Vb 1
\& $point = [$x_coord,$y_coord];
.Ve
.PP
A polygon is a reference to an (ordered) array of points.  The first point is the
begin and end point of the polygon. The points can be given in any direction
(clockwise or counter clockwise).
.PP
A contour is a reference to an array of polygons.  By convention, the first polygon
is the outer shape, all other polygons represent holes in the outer shape.  The outer
shape must enclose all holes !
Using this convention, the points can be given in any direction, however, keep
in mind that some functions (e.g. triangulation) require that the outer polygons
are entered in counter clockwise order and the inner polygons (holes) in clock
wise order.  The points, polygons, add_polygons methods will automatically set the
right order of points.
No points can be assigned to an object that already has polygons assigned to and
vice versa.
.PP
.Vb 5
\& $points = [[$x1,$y1],[$x2,$y2], ... ];
\& $polygon\->points($points);                    # assign points to polygon object
\& $points1 = [[$x1,$y1],[$x2,$y2], ... ];
\& $points2 = [[ax1,by1],[ax2,by2], ... ];
\& $contour\->polygons([$points1,$points2, ...]); # assign polgyons to contour object
.Ve
.SH "METHODS"
.IX Header "METHODS"
The available methods are:
.PP
\f(CW$polygon\fR\->points(arg);
.IX Subsection "$polygon->points(arg);"
.PP
Returns the polygon points if no argument is entered.
If the argument is a refence to a points array, sets the points for a polygon object.
.PP
\f(CW$contour\fR\->polygons(arg);
.IX Subsection "$contour->polygons(arg);"
.PP
Returns the contour polygons if no argument is entered.
If the argument is a refence to a polygons array, sets the polygons for a contour object.
.PP
\f(CW$contour\fR\->num_polygons;
.IX Subsection "$contour->num_polygons;"
.PP
Returns the total number of polygons in the contour.
.PP
\f(CW$contour\fR\->add_polygons(arg);
.IX Subsection "$contour->add_polygons(arg);"
.PP
Adds a list of polygons to a contour object (if the contour object doesn't have any
polygons yet, the very first polygon reference from the list is used as the outer
shape).  Returns the total number of polygons in the contour.
.PP
\f(CW$contour\fR\->get_polygons(arg_1,arg_2, ... );
.IX Subsection "$contour->get_polygons(arg_1,arg_2, ... );"
.PP
Returns a list of polygons where each element of the list corresponds to the polygon
at index arg_x \- starting at 0, the outer shape. If the index arg_x is out of range,
the corresponding value in the result list wil be undefined.  If no argument is
entered, a full list of all polygons is returned. Please note that this method returns
a list rather then a reference.
.PP
\f(CW$polygon\fR\->cleanup;
.IX Subsection "$polygon->cleanup;"
.PP
Remove colinear points from the polygon/contour.
.PP
\f(CW$polygon\fR\->isconvex;
.IX Subsection "$polygon->isconvex;"
.PP
Returns true if the polygon/contour is convex. A contour is considered to be convex if
the outer shape is convex.
.PP
\f(CW$polygon\fR\->issimple;
.IX Subsection "$polygon->issimple;"
.PP
Returns true if the polygon/contour is simple.  A contour is considered to be simple if
all it's polygons are simple.
.PP
\f(CW$polygon\fR\->perimeter;
.IX Subsection "$polygon->perimeter;"
.PP
Returns the perimeter of the polygon/contour. The perimeter of a contour is the perimeter
of the outer shape.
.PP
\f(CW$polygon\fR\->area;
.IX Subsection "$polygon->area;"
.PP
Returns the signed area of the polygon/contour (positive if the points are in counter
clockwise order). The area of a contour is the area of the outer shape minus the sum
of the area of the holes.
.PP
\f(CW$polygon\fR\->centroid;
.IX Subsection "$polygon->centroid;"
.PP
Returns the centroid (center of gravity) of the polygon/contour.
.PP
\f(CW$polygon\fR\->isinside($point);
.IX Subsection "$polygon->isinside($point);"
.PP
Returns true if point is inside the polygon/contour (a point is inside a contour if
it is inside the outer polygon and not inside a hole).
.PP
\f(CW$polygon\fR\->rotate($angle,$center);
.IX Subsection "$polygon->rotate($angle,$center);"
.PP
Returns polygon/contour rotated \f(CW$angle\fR (in radians) around \f(CW$center\fR.
If no center is entered, rotates around the origin.
.PP
\f(CW$polygon\fR\->move($dx,$dy);
.IX Subsection "$polygon->move($dx,$dy);"
.PP
Returns polygon/contour moved \f(CW$dx\fR in x direction and \f(CW$dy\fR in y direction.
.PP
\f(CW$polygon\fR\->mirrorx($center);
.IX Subsection "$polygon->mirrorx($center);"
.PP
Returns polygon/contour mirrored in x direction
with (vertical) axis of reflection through point \f(CW$center\fR.
If no center is entered, axis is the Y\-axis.
.PP
\f(CW$polygon\fR\->mirrory($center);
.IX Subsection "$polygon->mirrory($center);"
.PP
Returns polygon/contour mirrored in y direction
with (horizontal) axis of reflection through point \f(CW$center\fR.
If no center is entered, axis is the X\-axis.
.PP
\f(CW$polygon\fR\->mirror($axos);
.IX Subsection "$polygon->mirror($axos);"
.PP
Returns polygon mirrored/contour along axis \f(CW$axis\fR (= array with 2 points defining
axis of reflection).
.PP
\f(CW$polygon\fR\->scale($csale,$center);
.IX Subsection "$polygon->scale($csale,$center);"
.PP
Returns polygon/contour scaled by a factor \f(CW$scale\fR, center of scaling is \f(CW$scale\fR.
If no center is entered, center of scaling is the origin.
.PP
\f(CW$polygon\fR\->bbox;
.IX Subsection "$polygon->bbox;"
.PP
Returns the polygon's/contour's bounding box.
.PP
\f(CW$polygon\fR\->minrectangle;
.IX Subsection "$polygon->minrectangle;"
.PP
Returns the polygon's/contour's minimal (area) enclosing rectangle.
.PP
\f(CW$polygon\fR\->convexhull;
.IX Subsection "$polygon->convexhull;"
.PP
Returns a polygon representing the convex hull of the polygon/contour.
.PP
\f(CW$polygon\fR\->convexhull2;
.IX Subsection "$polygon->convexhull2;"
.PP
Returns a polygon representing the convex hull of an arbitrary set of points
(works also on a contour, however a contour is a set of polygons and polygons
are ordered sets of points so the method above will be faster)
.PP
\f(CW$polygon\fR\->triangulate;
.IX Subsection "$polygon->triangulate;"
.PP
Triangulates a polygon/contour based on Raimund Seidel's algorithm:
\&'A simple and fast incremental randomized algorithm for computing trapezoidal
decompositions and for triangulating polygons'
Returns a list of polygons (= the triangles)
.PP
\f(CW$polygon\fR\->offset_polygon($distance);
.IX Subsection "$polygon->offset_polygon($distance);"
.PP
Returns reference to an array of polygons representing the original polygon
offsetted by \f(CW$distance\fR
.PP
\f(CW$polygon\fR\->convert2gpc;
.IX Subsection "$polygon->convert2gpc;"
.PP
Converts a polygon/contour to a gpc structure and returns the resulting gpc structure
.SH "EXPORTS"
.IX Header "EXPORTS"
SegmentLength[$p1,$p2];
.IX Subsection "SegmentLength[$p1,$p2];"
.PP
Returns the length of the segment (vector) p1p2
.PP
Determinant(x1,y1,x2,y2);
.IX Subsection "Determinant(x1,y1,x2,y2);"
.PP
Returns the determinant of the matrix with rows x1,y1 and x2,y2 which is x1*y2 \- y1*x2
.PP
DotProduct($p1,$p2,$p3,$p4);
.IX Subsection "DotProduct($p1,$p2,$p3,$p4);"
.PP
Returns the vector dot product of vectors p1p2 and p3p4
or the dot product of p1p2 and p2p3 if \f(CW$p4\fR is ommited from the argument list
.PP
CrossProduct($p1,$p2,$p3);
.IX Subsection "CrossProduct($p1,$p2,$p3);"
.PP
Returns the vector cross product of vectors p1p2 and p1p3
.PP
TriangleArea($p1,$p2,$p3);
.IX Subsection "TriangleArea($p1,$p2,$p3);"
.PP
Returns the signed area of the triangle p1p2p3
.PP
Colinear($p1,$p2,$p3);
.IX Subsection "Colinear($p1,$p2,$p3);"
.PP
Returns true if p1,p2 and p3 are colinear
.PP
SegmentIntersection($p1,$p2,$p3,$p4);
.IX Subsection "SegmentIntersection($p1,$p2,$p3,$p4);"
.PP
Returns the intersection point of segments p1p2 and p3p4,
false if segments don't intersect
.PP
LineIntersection($p1,$p2,$p3,$p4);
.IX Subsection "LineIntersection($p1,$p2,$p3,$p4);"
.PP
Returns the intersection point of lines p1p2 and p3p4,
false if lines don't intersect (parallel lines)
.PP
RayIntersection($p1,$p2,$p3,$p4);
.IX Subsection "RayIntersection($p1,$p2,$p3,$p4);"
.PP
Returns the intersection point of rays p1p2 and p3p4,
false if lines don't intersect (parallel rays)
p1 (p3) is the startpoint of the ray and p2 (p4) is
a point on the ray.
.PP
RayLineIntersection($p1,$p2,$p3,$p4);
.IX Subsection "RayLineIntersection($p1,$p2,$p3,$p4);"
.PP
Returns the intersection point of ray p1p2 and line p3p4,
false if lines don't intersect (parallel rays)
p1 is the startpoint of the ray and p2 is a point on the ray.
.PP
SegmentLineIntersection($p1,$p2,$p3,$p4);
.IX Subsection "SegmentLineIntersection($p1,$p2,$p3,$p4);"
.PP
Returns the intersection point of segment p1p2 and line p3p4,
false if lines don't intersect (parallel rays)
.PP
SegmentRayIntersection($p1,$p2,$p3,$p4);
.IX Subsection "SegmentRayIntersection($p1,$p2,$p3,$p4);"
.PP
Returns the intersection point of segment p1p2 and ray p3p4,
false if lines don't intersect (parallel rays)
p3 is the startpoint of the ray and p4 is a point on the ray.
.PP
Perpendicular($p1,$p2,$p3,$p4);
.IX Subsection "Perpendicular($p1,$p2,$p3,$p4);"
.PP
Returns true if lines (segments) p1p2 and p3p4 are perpendicular
.PP
PerpendicularFoot($p1,$p2,$p3);
.IX Subsection "PerpendicularFoot($p1,$p2,$p3);"
.PP
Returns the perpendicular foot of p3 on line p1p2
.PP
DistanceToLine($p1,$p2,$p3);
.IX Subsection "DistanceToLine($p1,$p2,$p3);"
.PP
Returns the perpendicular distance of p3 to line p1p2
.PP
DistanceToSegment($p1,$p2,$p3);
.IX Subsection "DistanceToSegment($p1,$p2,$p3);"
.PP
Returns the distance of p3 to segment p1p2. Depending on the point's
position, this is the distance to one of the endpoints or the
perpendicular distance to the segment.
.PP
Gpc2Polygons($gpc_contour);
.IX Subsection "Gpc2Polygons($gpc_contour);"
.PP
Converts a gpc contour structure to an array of contours and returns the array
.PP
GpcClip($operation,$gpc_contour_1,$gpc_contour_2);
.IX Subsection "GpcClip($operation,$gpc_contour_1,$gpc_contour_2);"
.PP
.Vb 3
\& $operation is DIFFERENCE, INTERSECTION, XOR or UNION
\& $gpc_polygon_1 is the source polygon
\& $gpc_polygon_2 is the clip polygon
.Ve
.PP
Returns a gpc polygon structure which is the result of the gpc clipping operation
.PP
CircleToPoly($i,$p1,$p2,$p3);
.IX Subsection "CircleToPoly($i,$p1,$p2,$p3);"
.PP
Converts the circle through points p1p2p3 to a polygon with i segments
.PP
CircleToPoly($i,$center,$p1);
.IX Subsection "CircleToPoly($i,$center,$p1);"
.PP
Converts the circle with center through point p1 to a polygon with i segments
.PP
CircleToPoly($i,$center,$radius);
.IX Subsection "CircleToPoly($i,$center,$radius);"
.PP
Converts the circle with center and radius to a polygon with i segments
.PP
ArcToPoly($i,$p1,$p2,$p3);
.IX Subsection "ArcToPoly($i,$p1,$p2,$p3);"
.PP
Converts the arc with begin point p1, intermediate point p2 and end point p3
to a (non-closed !) polygon with i segments
.PP
ArcToPoly($i,$center,$p1,$p2,$direction);
.IX Subsection "ArcToPoly($i,$center,$p1,$p2,$direction);"
.PP
Converts the arc with center, begin point p1 and end point p2 to a
(non-closed !) polygon with i segments.  If direction is 0, the arc
is traversed counter clockwise from p1 to p2, clockwise if direction is 1
